## 🌐 서브넷(Subnet)과 게이트웨이(Gateway)

**서브넷**과 **게이트웨이**는 네트워크 통신의 기본을 이루는 핵심 개념입니다. 두 요소는 협력하여 장치들이 로컬 네트워크 내에서 통신하고, 외부 네트워크(인터넷)로 데이터를 보낼 수 있게 합니다.

---

### 1. 서브넷 (Subnet, Subnetwork)

**서브넷**은 하나의 큰 네트워크를 관리하기 쉽고 효율적인 여러 개의 작은 네트워크로 **분할한 논리적인 네트워크 단위**를 의미합니다.

* **핵심 역할: 네트워크 범위 정의**
    * 서브넷은 **서브넷 마스크(Subnet Mask)**를 사용하여 IP 주소에서 **네트워크 영역**과 **호스트 영역**을 구분합니다.
    * 같은 서브넷에 속한 장치들은 **라우터(Router) 없이** 직접 통신할 수 있습니다. 이는 브로드캐스트를 이용한 직접적인 통신이 가능하기 때문입니다.
* **보안 및 효율성:**
    * 네트워크를 분할함으로써 **브로드캐스트 도메인**을 작게 나누어 트래픽을 줄이고 네트워크 성능을 향상시킵니다.
    * 각 서브넷을 독립적으로 관리할 수 있어 보안 정책 적용 및 문제 해결이 용이합니다 (예: VLAN을 이용한 서브넷 분리).
* **표기법:** CIDR 표기법(예: `192.168.1.0/24`)으로 표현되며, `/24`는 네트워크 비트 수를 나타냅니다.

---

### 2. 게이트웨이 (Gateway, Default Gateway)

**게이트웨이**는 서로 **다른 통신 프로토콜**을 사용하거나 **다른 네트워크(서브넷)**에 있는 장치들과 연결할 때 통로 역할을 하는 장치나 노드를 의미합니다. 일반적인 로컬 네트워크 환경에서 게이트웨이는 주로 **라우터(Router)**의 로컬 네트워크 측 인터페이스 주소를 가리킵니다.

* **핵심 역할: 외부 통신 통로**
    * 장치가 **자신이 속하지 않은 서브넷**으로 데이터를 보내야 할 때, 모든 패킷을 게이트웨이로 전달합니다.
    * 게이트웨이(라우터)는 해당 패킷의 목적지 IP 주소를 보고, 패킷이 나갈 다음 경로(Next Hop)를 결정하여 외부 네트워크로 데이터를 전달하는 **라우팅** 역할을 수행합니다.
* **설정 필수:** PC와 같은 호스트 장치에 IP 주소와 서브넷 마스크를 설정할 때 **반드시 게이트웨이 주소**를 명시해야 합니다. 게이트웨이가 없으면 로컬 네트워크를 벗어난 인터넷 등의 외부 통신이 불가능합니다.

---

### 💡 서브넷과 게이트웨이의 관계 (실전 팁)

서브넷과 게이트웨이는 통신 대상을 판단하는 **두 가지 규칙**에 사용됩니다.

1.  **로컬 통신 규칙 (서브넷):**
    * **"나와 목적지 IP 주소를 서브넷 마스크로 씌워본 결과, 네트워크 주소가 같다면?"** $\rightarrow$ 로컬 네트워크 통신이므로 **ARP 요청** 후 직접 패킷 전송.
2.  **외부 통신 규칙 (게이트웨이):**
    * **"나와 목적지 IP 주소를 서브넷 마스크로 씌워본 결과, 네트워크 주소가 다르다면?"** $\rightarrow$ 외부 네트워크 통신이므로 패킷을 **게이트웨이 주소로 전송**.

이러한 메커니즘을 통해 모든 네트워크 장치는 자신이 속한 환경과 외부 환경을 명확히 구분하여 효율적으로 통신할 수 있습니다.

---
## 🧱 서브넷 (Subnet)과 서브넷팅 (Subnetting) 

**서브넷(Subnet, 서브네트워크)**은 기존의 큰 네트워크를 **더 작고 관리하기 쉬운 여러 개의 논리적인 네트워크**로 나눈 것을 의미합니다. 이 과정을 **서브넷팅(Subnetting)**이라고 합니다.

서브넷팅은 현재 표준인 **CIDR(클래스 없는 라우팅)** 방식의 핵심 기술이며, IP 주소 낭비를 막고 네트워크 효율성과 보안을 높이는 데 필수적입니다.

---

### 1. 🔍 서브넷팅의 기본 원리

서브넷팅은 IP 주소의 일부인 **호스트 ID(Host ID)** 비트를 강제로 빌려와서 **네트워크 ID**로 사용하는 원리를 이용합니다.

| 구분 | IP 주소의 구성 | 서브넷팅 시 변화 |
| :---: | :---: | :--- |
| **기존** | **네트워크 ID** (고정) + **호스트 ID** (사용) |
| **서브넷팅** | **네트워크 ID** (고정) + **서브넷 ID** (빌려온 비트) + **호스트 ID** (남은 비트) |

* **서브넷 마스크의 역할**: 서브넷 마스크는 이 새로운 경계(서브넷 ID + 호스트 ID)를 표시하는 역할을 합니다. 마스크의 길이가 길어질수록(예: `/24`에서 `/27`로) 네트워크 수는 늘어나고, 각 서브넷의 호스트 수는 줄어듭니다.

---

### 2. 💡 서브넷팅의 목적과 이점

서브넷팅을 수행하는 주요 이점은 다음과 같습니다.

| 이점 | 설명 |
| :---: | :--- |
| **주소 낭비 방지** | 필요한 만큼만 네트워크를 나누어 **IP 주소의 낭비**를 최소화합니다 (CIDR/VLSM). |
| **트래픽 부하 감소** | 로컬 트래픽을 작은 서브넷 내에 가두어, 브로드캐스트 트래픽이 전체 네트워크로 퍼지는 것을 방지하고 네트워크 성능을 향상시킵니다. |
| **보안 강화** | 각 서브넷을 방화벽이나 ACL(Access Control List)로 분리하여, 한 서브넷에서 발생한 문제가 전체 네트워크로 확산되는 것을 막고 **접근 제어를 강화**합니다. |
| **관리 용이성** | 논리적으로 분리된 서브넷은 문제 발생 시 해당 서브넷만 격리하여 문제 해결을 쉽게 만듭니다. |

---
## 📊 CIDR 프리픽스별 서브넷 분할 상세 비교 (기준: `192.168.1.0/24`)

| CIDR Prefix | 서브넷 마스크 | 빌려온 비트 (N) | 생성 서브넷 개수 ($2^N$) | 호스트 비트 (H) | 사용 가능 호스트 수 ($2^H-2$) |
| :---: | :---: | :---: | :---: | :---: | :---: |
| **/25** | **255.255.255.128** | 1개 | **2개** | 7개 | 126개 |
| **/26** | **255.255.255.192** | 2개 | **4개** | 6개 | 62개 |
| **/27** | **255.255.255.224** | 3개 | **8개** | 5개 | 30개 |

-----

## 🗺️ 각 프리픽스별 네트워크 주소 및 IP 범위

### 1\.  subnetting with /25 (서브넷 2개)

| 서브넷 번호 | 네트워크 ID | 사용 가능 IP 범위 | 브로드캐스트 주소 |
| :---: | :---: | :---: | :---: |
| **Subnet 1** | **192.168.1.0** | 192.168.1.1 \~ 192.168.1.126 | 192.168.1.127 |
| **Subnet 2** | **192.168.1.128** | 192.168.1.129 \~ 192.168.1.254 | 192.168.1.255 |

<br>

### 2\. subnetting with /26 (서브넷 4개)

| 서브넷 번호 | 네트워크 ID | 사용 가능 IP 범위 | 브로드캐스트 주소 |
| :---: | :---: | :---: | :---: |
| **Subnet 1** | **192.168.1.0** | 192.168.1.1 \~ 192.168.1.62 | 192.168.1.63 |
| **Subnet 2** | **192.168.1.64** | 192.168.1.65 \~ 192.168.1.126 | 192.168.1.127 |
| **Subnet 3** | **192.168.1.128** | 192.168.1.129 \~ 192.168.1.190 | 192.168.1.191 |
| **Subnet 4** | **192.168.1.192** | 192.168.1.193 \~ 192.168.1.254 | 192.168.1.255 |

<br>

### 3\. subnetting with /27 (서브넷 8개)

| 서브넷 번호 | 네트워크 ID | 사용 가능 IP 범위 | 브로드캐스트 주소 |
| :---: | :---: | :---: | :---: |
| **Subnet 1** | **192.168.1.0** | 192.168.1.1 \~ 192.168.1.30 | 192.168.1.31 |
| **Subnet 2** | **192.168.1.32** | 192.168.1.33 \~ 192.168.1.62 | 192.168.1.63 |
| **Subnet 3** | **192.168.1.64** | 192.168.1.65 \~ 192.168.1.94 | 192.168.1.95 |
| **Subnet 4** | **192.168.1.96** | 192.168.1.97 \~ 192.168.1.126 | 192.168.1.127 |
| **Subnet 5** | **192.168.1.128** | 192.168.1.129 \~ 192.168.1.158 | 192.168.1.159 |
| **Subnet 6** | **192.168.1.160** | 192.168.1.161 \~ 192.168.1.190 | 192.168.1.191 |
| **Subnet 7** | **192.168.1.192** | 192.168.1.193 \~ 192.168.1.222 | 192.168.1.223 |
| **Subnet 8** | **192.168.1.224** | 192.168.1.225 \~ 192.168.1.254 | 192.168.1.255 |

-----

### 💡 실전 팁: 서브넷 마스크 (마지막 옥텟)의 값

서브넷 마스크의 마지막 옥텟 값은 다음과 같은 규칙으로 계산됩니다.

$$
\text{마스크 값} = 256 - \text{각 서브넷의 주소 개수}
$$

  * **$/25$**: 주소 개수 128개 $\rightarrow 256 - 128 = **128**$
  * **$/26$**: 주소 개수 64개 $\rightarrow 256 - 64 = **192**$
  * **$/27$**: 주소 개수 32개 $\rightarrow 256 - 32 = **224**$
---
### 3. 🔢 서브넷팅 실습 예제: 네트워크 분할

네트워크 **`192.168.1.0/24`**를 **4개의 서브넷**으로 나누는 과정을 예시로 들어 설명합니다.

#### 🔸 초기 조건 (클래스 C 기준)

* **주소**: `192.168.1.0`
* **Prefix**: `/24` (24비트가 네트워크 ID)
* **기본 서브넷 마스크**: `255.255.255.0`
* **호스트 비트**: 8비트 (마지막 옥텟 전체)

#### 🔹 4개 서브넷 생성 과정

1.  **필요한 비트 수 계산**: 4개의 서브넷을 만들려면 $2^n \ge 4$를 만족해야 합니다. 따라서 **2비트**($n=2$)를 호스트 비트에서 빌려와 **서브넷 ID**로 사용합니다.
2.  **새로운 Prefix**: 기존 `/24`에 2비트를 추가하여 **`/26`**이 됩니다.
3.  **호스트 비트**: 남은 비트는 $32 - 26 = **6비트**입니다. 이 6비트가 각 서브넷의 호스트 ID가 됩니다.
    * **각 서브넷의 크기**: $2^6 = 64$개의 주소 (사용 가능 호스트 수는 $64 - 2 = 62$개).
4.  **서브넷 마스크**: `/26`은 마지막 옥텟의 상위 2비트가 `1`이 됩니다.
    * $11000000_2 = 128 + 64 = 192$
    * 새로운 서브넷 마스크: **`255.255.255.192`**

#### 🔸 서브넷 결과 테이블

| 서브넷 ID (2비트) | 네트워크 주소 (CIDR) | 호스트 주소 범위 | 브로드캐스트 주소 |
| :---: | :---: | :---: | :---: |
| 00 | **192.168.1.0/26** | 192.168.1.1 ~ 192.168.1.62 | 192.168.1.63 |
| 01 | **192.168.1.64/26** | 192.168.1.65 ~ 192.168.1.126 | 192.168.1.127 |
| 10 | **192.168.1.128/26** | 192.168.1.129 ~ 192.168.1.190 | 192.168.1.191 |
| 11 | **192.168.1.192/26** | 192.168.1.193 ~ 192.168.1.254 | 192.168.1.255 |

* **실전 팁**: 각 서브넷의 첫 번째 주소는 **네트워크 주소**이며, 마지막 주소는 해당 서브넷의 **브로드캐스트 주소**입니다. 이 두 주소는 호스트 장치에 할당할 수 없습니다.

이제 원래 하나의 네트워크였던 `192.168.1.0/24`는 4개의 독립된 서브넷으로 분리되어, 각 서브넷은 서로 다른 라우터를 통해서만 통신할 수 있게 됩니다.
---


## 🔢 서브넷팅 실습 예제: `/25` Prefix 적용

요청하신 대로, **`/25`** 프리픽스(Prefix)를 사용하여 네트워크를 분할하는 서브넷팅 예제를 상세히 설명합니다. `/25`는 기존 클래스 C(`/24`) 네트워크에서 호스트 비트 1개를 빌려와 서브넷을 2개로 나누는 가장 간단한 형태의 서브넷팅입니다.

---

### 1. ⚙️ `/25` 서브넷의 기본 분석

네트워크 **`192.168.1.0`**을 기준으로 `/25` 서브넷을 분석합니다.

| 구분 | 계산 및 값 | 원리 |
| :---: | :---: | :--- |
| **Prefix Length** | **$/25$** | 32비트 중 25비트가 네트워크 ID로 사용됩니다. |
| **빌려온 비트 수** | **1비트** ($25 - 24$) | 기존 `/24`에서 1비트를 빌려와 서브넷 ID로 사용합니다. |
| **생성 서브넷 수** | $2^1 = \mathbf{2}$개 | 빌려온 1비트로 2개의 독립된 서브넷을 생성합니다. |
| **호스트 비트 수** | $32 - 25 = \mathbf{7}$비트 | 각 서브넷에 남은 호스트 ID 비트는 7개입니다. |
| **총 주소 수 (각 서브넷)** | $2^7 = \mathbf{128}$개 | 각 서브넷이 가질 수 있는 주소의 총 개수입니다. |
| **사용 가능 호스트 수** | $128 - 2 = \mathbf{126}$개 | 네트워크 주소와 브로드캐스트 주소를 제외한 실제 할당 가능한 호스트 수입니다. |

### 2. 📝 `/25` 서브넷 마스크 계산

`/25`는 32비트 중 25번째 비트까지 '1'로 채워진다는 의미입니다.

1.  **세 번째 옥텟까지**: `/24`까지는 `255.255.255.0`입니다.
2.  **네 번째 옥텟**: 25번째 비트가 네 번째 옥텟의 **첫 번째 비트**($2^7$)입니다.
    $$\underbrace{11111111}_{255} . \underbrace{11111111}_{255} . \underbrace{11111111}_{255} . \underbrace{\mathbf{1}0000000}_{128}$$
3.  **최종 서브넷 마스크**: **`255.255.255.128`**

### 3. 🗺️ `/25` 서브넷 분할 결과 예시

네트워크 **`192.168.1.0/24`**를 `/25`로 나누면, 두 개의 독립된 서브넷이 생성됩니다.

| 서브넷 번호 | 네트워크 주소 (CIDR) | 호스트 주소 범위 | 브로드캐스트 주소 |
| :---: | :---: | :---: | :---: |
| **Subnet 1** | **192.168.1.0/25** | 192.168.1.1 ~ 192.168.1.126 | 192.168.1.127 |
| **Subnet 2** | **192.168.1.128/25** | 192.168.1.129 ~ 192.168.1.254 | 192.168.1.255 |

#### 🔸 실전 분석

* **Subnet 1**은 `0`으로 시작하여 `127`에서 끝납니다. 이 서브넷에 속한 장치는 IP 주소의 8번째 옥텟에서 $0$부터 $127$까지만 사용할 수 있습니다.
* **Subnet 2**는 `128`로 시작하여 `255`에서 끝납니다. 이 서브넷에 속한 장치는 IP 주소의 8번째 옥텟에서 $128$부터 $255$까지만 사용할 수 있습니다.
* **라우팅의 경계**: 서브넷 1에 있는 장치(`192.168.1.10`)와 서브넷 2에 있는 장치(`192.168.1.150`)는 IP 주소만 보면 같은 네트워크인 것처럼 보이지만, 서브넷 마스크(`255.255.255.128`)가 다르기 때문에 **라우터**를 통해서만 통신할 수 있습니다.

이처럼 `/25`를 사용하면 기존 클래스 C 네트워크를 **정확히 절반**으로 나누어 관리 효율성과 보안성을 높일 수 있습니다.



---
## 🧠 서브넷팅 확인: 2진수 변환 및 AND 연산 실습

네트워크 장치가 특정 IP 주소가 **자신과 동일한 네트워크(서브넷)**에 속하는지 확인하는 핵심 과정은 **IP 주소**와 **서브넷 마스크**를 2진수로 변환하여 **AND 연산**을 수행하는 것입니다.

이 연산의 결과는 해당 서브넷의 **네트워크 주소(Network ID)**가 되며, 이 주소가 동일하면 같은 서브넷에 있는 것입니다.

### 1. 🔍 실습 목표 및 조건 설정

* **기본 네트워크**: `192.168.1.0/24`
* **서브넷 마스크**: `/26` (255.255.255.192)
* **테스트 서브넷**: **Subnet 1** (`192.168.1.0/26`)과 **Subnet 2** (`192.168.1.128/26`)
* **테스트 IP**:
    * IP A: `192.168.1.10` (Subnet 1 예상)
    * IP B: `192.168.1.130` (Subnet 2 예상)

---

### 2. ⚙️ IP A (`192.168.1.10`)의 네트워크 주소 계산

#### A. 2진수 변환

| 옥텟 | 10진수 | 2진수 (8비트) |
| :---: | :---: | :---: |
| **IP 주소** | 192.168.1.10 | 11000000 . 10101000 . 00000001 . **00001010** |
| **서브넷 마스크** | 255.255.255.192 | 11111111 . 11111111 . 11111111 . **11**000000 |

#### B. 비트별 AND 연산

AND 연산은 두 비트가 모두 '1'일 때만 '1'을 반환합니다.

$$\begin{array}{c|c|c|c|c}
\text{IP 주소} & 11000000 & 10101000 & 00000001 & \mathbf{00}001010 \\
\text{AND 마스크} & 11111111 & 11111111 & 11111111 & \mathbf{11}000000 \\
\hline
\text{결과 (네트워크 ID)} & 11000000 & 10101000 & 00000001 & \mathbf{00}000000 \\
\end{array}$$

#### C. 결과 해석

| 옥텟 | 2진수 | 10진수 |
| :---: | :---: | :---: |
| **네트워크 ID** | 11000000 . 10101000 . 00000001 . 00000000 | **192.168.1.0** |

* IP A (`192.168.1.10`)의 네트워크 주소는 **`192.168.1.0`**이므로, **Subnet 1**에 속함을 확인했습니다.

---

### 3. ⚙️ IP B (`192.168.1.130`)의 네트워크 주소 계산

#### A. 2진수 변환

| 옥텟 | 10진수 | 2진수 (8비트) |
| :---: | :---: | :---: |
| **IP 주소** | 192.168.1.130 | 11000000 . 10101000 . 00000001 . **10**000010 |
| **서브넷 마스크** | 255.255.255.192 | 11111111 . 11111111 . 11111111 . **11**000000 |

#### B. 비트별 AND 연산

$$\begin{array}{c|c|c|c|c}
\text{IP 주소} & 11000000 & 10101000 & 00000001 & \mathbf{10}000010 \\
\text{AND 마스크} & 11111111 & 11111111 & 11111111 & \mathbf{11}000000 \\
\hline
\text{결과 (네트워크 ID)} & 11000000 & 10101000 & 00000001 & \mathbf{10}000000 \\
\end{array}$$

#### C. 결과 해석

| 옥텟 | 2진수 | 10진수 |
| :---: | :---: | :---: |
| **네트워크 ID** | 11000000 . 10101000 . 00000001 . 10000000 | **192.168.1.128** |

* IP B (`192.168.1.130`)의 네트워크 주소는 **`192.168.1.128`**이므로, **Subnet 2**에 속함을 확인했습니다.

### 4. 💡 결론 및 실전 팁

* **동일 서브넷 판단**: 장치들은 자신의 IP 주소와 서브넷 마스크를 AND 연산하여 얻은 네트워크 ID와, 통신하려는 상대방의 IP 주소와 마스크를 연산하여 얻은 네트워크 ID가 **일치하는지** 확인합니다.
* **결과**: IP A의 네트워크 ID는 `.0`이고, IP B의 네트워크 ID는 `.128`이므로, 이 두 IP는 **서로 다른 서브넷**에 있으며 **라우터를 통해서만 통신**할 수 있습니다.

이 AND 연산 과정은 모든 네트워크 장치(PC, 스위치, 라우터)가 패킷을 로컬로 보낼지, 아니면 라우터(게이트웨이)로 포워딩할지를 결정하는 근본적인 원리입니다.

