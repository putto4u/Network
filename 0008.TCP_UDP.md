TCP/IP와 데이터 전송 프로토콜은 모든 **네트워크(Network)** 및 **보안(Security)** 지식의 핵심 기반입니다. 네트워크 프로그래밍이나 **AI** 환경의 데이터 송수신 과정을 이해하는 데 필수적인 내용입니다.

---

## 1.  TCP/IP 모델 이해 (인터넷 통신의 표준)

**TCP/IP(Transmission Control Protocol/Internet Protocol)**는 현재 인터넷에서 데이터를 전송하는 데 사용되는 **사실상의 표준 통신 프로토콜 스택**입니다.

### TCP/IP 4계층 모델 구성

TCP/IP 모델은 OSI 7 계층 모델을 간소화하여 실용성에 초점을 맞춘 4개의 계층으로 구성됩니다.

| 계층 | OSI 7 Layer 매핑 | 주요 역할 | 핵심 프로토콜 |
| :---: | :--- | :--- | :--- |
| **4. 응용 계층** | L7, L6, L5 | 사용자에게 서비스 제공. 데이터 생성 및 교환. | **HTTP**, FTP, SMTP, SSH, DNS |
| **3. 전송 계층** | L4 | **데이터 전송의 신뢰성** 및 **흐름 제어** 담당. 포트 번호로 프로세스 구분. | **TCP**, **UDP** |
| **2. 인터넷 계층** | L3 | **데이터 패킷의 경로 설정(라우팅)** 및 논리적 주소 지정. | **IP**, ICMP, ARP |
| **1. 네트워크 접근 계층** | L2, L1 | 물리적 네트워크를 통해 데이터 프레임을 전송. | Ethernet, Wi-Fi, MAC 주소 |

---

## 2.  핵심 전송 프로토콜: TCP vs. UDP 비교

전송 계층(L4)에서 가장 중요한 두 가지 프로토콜인 **TCP**와 **UDP**는 데이터 전송 방식과 목적이 극명하게 다릅니다.

| 특징 | TCP (Transmission Control Protocol) | UDP (User Datagram Protocol) |
| :--- | :--- | :--- |
| **연결 방식** | **연결 지향 (Connection-Oriented)** | **비연결 지향 (Connectionless)** |
| **신뢰성** | **높음** (데이터 손실/오류 없음 보장) | **낮음** (데이터 손실/순서 변경 가능) |
| **전송 속도** | **느림** (핸드셰이크, 재전송 등 오버헤드 발생) | **빠름** (최소한의 오버헤드) |
| **흐름/혼잡 제어** | **제공** (수신자가 처리 가능한 속도로 조절) | **제공하지 않음** (무조건 전송) |
| **사용 예시** | 웹(HTTP), 이메일(SMTP), 파일 전송(FTP), **DB 연결** | DNS, 실시간 스트리밍, 음성 통화(VoIP), 온라인 게임 |

<img width="437" height="208" alt="image" src="https://github.com/user-attachments/assets/9fade742-3e21-434c-acad-0c0a02e7ab9f" />



###  TCP의 3-Way Handshake (신뢰성 확보의 핵심)

TCP가 연결 지향성과 신뢰성을 확보하는 핵심 메커니즘입니다. 데이터를 주고받기 전에 송신자와 수신자가 3단계의 통신을 통해 연결을 설정합니다.

1.  **SYN (Synchronize Sequence Number):** 클라이언트가 서버에게 연결을 요청합니다.
2.  **SYN-ACK (Acknowledgement):** 서버가 클라이언트의 요청을 수락하고, 자신도 연결을 요청합니다.
3.  **ACK (Acknowledgement):** 클라이언트가 서버의 요청을 수락하며, **비로소 데이터 통신이 가능**한 상태가 됩니다.

> ** 팁 (파이썬/보안):**
>
> 1.  **파이썬:** **소켓 프로그래밍** 시 `SOCK_STREAM`은 TCP를, `SOCK_DGRAM`은 UDP를 의미합니다. 안정적인 DB 통신이나 웹 서비스 개발에는 TCP를 사용하고, 빠른 데이터 스트리밍에는 UDP를 고려해야 함을 설명해 주십시오.
> 2.  **보안:** TCP 3-Way Handshake를 이용한 **SYN Flooding** 공격이나, UDP의 비연결성을 이용한 **DNS 증폭(Amplification)** 공격 등 보안 취약점 사례



<img width="1198" height="455" alt="image" src="https://github.com/user-attachments/assets/5dbfa673-cd7c-4350-b02a-4d90715c36b0" />

## (이더넷)프레임, IPv4 패킷, TCP/UDP 헤더 구조



<img width="1507" height="1548" alt="image" src="https://github.com/user-attachments/assets/b1d9c0bc-6e04-4c98-806e-4154770a68de" />





---
##  데이터 전송 과정: 캡슐화 시뮬레이션

실제 데이터가 'A'부터 'Z'까지의 알파벳이고, 한 페이지를 7자로 가정하여 두 PC가 TCP/IP로 통신할 때 데이터에 씌워지는 **주요 헤더**들을 캡슐화 과정을 통해 상세히 설명해 드리겠습니다.

이 시나리오에서는 'A'부터 'Z'까지 총 26바이트의 데이터가 있으며, **전송 계층(TCP)**에서 7바이트씩 분할된다고 가정합니다.


### 시나리오 개요

* **원본 데이터 (Application Data, L7):** `ABCDEFGHI...Z` (26자)
* **분할 크기 (TCP Segment Payload):** 7자
* **통신 방식:** 신뢰성이 필요한 **TCP** 통신

### 1단계: 응용 계층 (L7) - 데이터 생성

| 데이터 |
| :---: |
| `ABCDEFGHI...Z` |
* **역할:** 웹 브라우저나 FTP 클라이언트와 같은 응용 프로그램이 데이터를 생성합니다.

---

### 2단계: 전송 계층 (L4) - TCP 헤더 씌우기

L4에서는 26자의 데이터가 7자 단위로 분할되어 **세그먼트(Segment)**가 됩니다. 각 세그먼트에는 TCP 헤더가 추가됩니다.

#### 2-1. 데이터 분할

* **Segment #1 (7자):** `ABCDEFG`
* **Segment #2 (7자):** `HIJKLMN`
* **Segment #3 (7자):** `OPQRSTU`
* **Segment #4 (5자):** `VWXYZ` (마지막 조각)

#### 2-2. TCP 헤더 (20~60 바이트) 추가

각 세그먼트에 **TCP 헤더**가 붙습니다.

| 주요 필드 | 역할 | 예시 값 (Segment #1) |
| :--- | :--- | :--- |
| **출발지 포트** | 데이터를 보낸 애플리케이션 포트 번호. | `49152` (임시 포트) |
| **목적지 포트** | 데이터를 받을 서버의 서비스 포트 번호. | `80` (HTTP) 또는 `3306` (MySQL DB) |
| **순서 번호 (Seq Num)** | 이 세그먼트의 첫 번째 바이트의 **데이터 순서 번호**. | `1` (첫 번째 바이트) |
| **확인 응답 번호 (ACK Num)** | **수신자가 다음에 받기 원하는 바이트** 번호. (통신 중에는 상대방의 ACK 번호가 담김) | `0` (최초 전송 시) |
| **플래그 (Flags)** | 연결/종료/재전송 등 제어 정보 (**SYN, ACK, FIN** 등). | `SYN` (최초 연결 시) |


### 3단계: 인터넷 계층 (L3) - IP 헤더 씌우기

L3에서는 각 TCP 세그먼트에 **IP 헤더**가 붙어 **패킷(Packet)**이 됩니다. **각 세그먼트는 이제 독립적인 패킷입니다.**

#### IP 헤더 (20~60 바이트) 추가

| 주요 필드 | 역할 | 예시 값 |
| :--- | :--- | :--- |
| **출발지 IP 주소** | 데이터를 보낸 PC의 논리적 주소. | `192.168.1.100` |
| **목적지 IP 주소** | 데이터를 받을 서버의 논리적 주소. | `203.0.113.50` |
| **프로토콜** | 상위 계층(L4)에서 사용된 프로토콜 (TCP=6, UDP=17). | `6` (TCP) |
| **TTL** | 패킷이 네트워크에서 무한 루프에 빠지는 것을 방지하는 값. | `64` |


---

### 4단계: 네트워크 접근 계층 (L2) - MAC 헤더 씌우기

L2에서는 각 패킷에 **MAC 헤더와 트레일러**가 붙어 **프레임(Frame)**이 됩니다. MAC 주소는 라우터나 스위치와 같은 **인접 장치** 간의 통신에 사용됩니다.

#### MAC 헤더 (14~18 바이트) 추가

| 주요 필드 | 역할 | 예시 값 (PC → 라우터) |
| :--- | :--- | :--- |
| **출발지 MAC 주소** | 데이터를 보낸 PC의 NIC 물리 주소. | `A1:B2:C3:D4:E5:F6` |
| **목적지 MAC 주소** | PC와 직접 연결된 **라우터/스위치**의 MAC 주소. | `11:22:33:44:55:66` |


---

##  데이터 전송과 헤더 변화 (라우팅)

Frame #1은 네트워크를 따라 전송됩니다.

1.  **PC에서 라우터로:** Frame #1이 전송되면, 라우터는 MAC 헤더를 확인하고(L2 처리) 제거한 후, **IP 헤더**를 읽어(L3 처리) 다음 목적지 경로를 결정합니다.
2.  **라우터의 역할:** 라우터는 **IP 주소** (출발지/목적지)는 **그대로** 유지하지만, 다음 라우터로 데이터를 보내기 위해 **새로운 MAC 주소(출발지: 라우터, 목적지: 다음 라우터)**를 씌워 **새로운 Frame**을 만듭니다.
3.  **최종 서버 도착:** 이 과정이 반복되어 패킷이 최종 서버에 도착하고, 서버는 역캡슐화 과정을 통해 헤더들을 차례로 제거하고 최종 데이터 `ABCDEFG`를 L7 애플리케이션에 전달하게 됩니다.

> **IT 전문가 팁:**
>
> **L3(IP) 헤더**는 **End-to-End** 통신을 위해 출발지/목적지 정보를 **변화 없이** 전달하며, **L2(MAC) 헤더**는 **Hop-by-Hop** 통신을 위해 **거치는 장비마다 계속 변경**됨.

"페이지(Page)"라는 용어는 사용되는 IT 분야에 따라 의미와 크기가 완전히 달라지기 때문에, 강사님께서 어떤 맥락으로 질문하셨는지에 따라 답변이 달라집니다.

가장 흔하게 사용되는 세 가지 "페이지"의 실제 크기를 비교하여 설명해 드리겠습니다.

---
---

## 1.  네트워크 통신에서의 '페이지' 크기 (MSS/MTU)

여기서 '페이지'는 데이터를 전송하기 위해 쪼개는 **최대 크기 단위**를 의미하며, 주로 **MTU**와 **MSS**를 통해 결정됩니다.

| 용어 | 실제 의미 | 일반적인 크기 |
| :--- | :--- | :--- |
| **MTU** (Maximum Transmission Unit) | **L2/L3 패킷**의 **최대 크기** (헤더 포함). | **1,500 바이트** (표준 이더넷) |
| **MSS** (Maximum Segment Size) | **L4 TCP 세그먼트**에 담을 수 있는 **순수 데이터(페이로드)**의 **최대 크기**. | **1,460 바이트** (MTU 1,500에서 IP 헤더 20B + TCP 헤더 20B를 제외) |

**결론:** 네트워크 통신에서 '한 페이지'는 보통 **1,460 바이트**의 순수 데이터를 의미하며, 이는 데이터가 TCP/IP 프로토콜 스택에 의해 자동으로 쪼개지는 최대 단위입니다. 실제로는 효율성을 위해 최대 크기(1,460 바이트)를 활용합니다.

---

## 2.  운영체제(OS)에서의 '페이지' 크기

운영체제(OS)의 가상 메모리 시스템에서 사용하는 '페이지'는 메모리 관리의 최소 단위입니다.

| 용어 | 실제 의미 | 일반적인 크기 |
| :--- | :--- | :--- |
| **OS 페이지** | 가상 메모리를 물리 메모리(RAM)의 **프레임**과 매핑하는 고정 크기 블록. | **4KB (4,096 바이트)** |

**결론:** OS에서 '페이지'는 일반적으로 **4KB**이며, 이 크기는 내부 단편화, 페이지 테이블 크기, 디스크 입출력 효율성 등을 고려하여 OS가 결정합니다.

---

## 3.  웹 디자인에서의 '페이지' 크기 (픽셀)

이는 바이트 크기가 아닌 **화면 해상도**를 기준으로 합니다.

| 용어 | 실제 의미 | 일반적인 크기 |
| :--- | :--- | :--- |
| **웹 페이지** | 브라우저에 표시되는 콘텐츠의 **가로/세로 픽셀** 크기. | 데스크톱: 1280px ~ 1920px (가로) |

**결론:** 웹 페이지 자체의 '크기'는 바이트가 아닌 **픽셀 단위**로 논의되며, 이는 기기 해상도(모바일, 데스크톱)에 따라 유동적입니다. 다만, 해당 페이지의 **총 파일 크기** (HTML, CSS, JS, 이미지 포함)는 수십 KB에서 수 MB까지 다양합니다.

---

###  요약

통신과 메모리에서의 '페이지'를 명확히 구분

* **네트워크 통신:** 1,460 바이트 (효율적인 데이터 전송 단위)
* **운영체제 메모리:** 4,096 바이트 (효율적인 메모리 관리 단위)
